// <auto-generated>
//     This code was generated by ToonFormat.SpecGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>


using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Nodes;
using Toon.Format;
using Xunit;


namespace Toon.Format.Tests.Decode;


[Trait("Category", "decode")]
public class PathExpansion
{
    [Fact]
    [Trait("Description", "expands dotted key to nested object in safe mode")]
    public void ExpandsDottedKeyToNestedObjectInSafeMode()
    {
        // Arrange
        var input =
"""
a.b.c: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":{"c":1}}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "expands dotted key with inline array")]
    public void ExpandsDottedKeyWithInlineArray()
    {
        // Arrange
        var input =
"""
data.meta.items[2]: a,b
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"data":{"meta":{"items":["a","b"]}}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "expands dotted key with tabular array")]
    public void ExpandsDottedKeyWithTabularArray()
    {
        // Arrange
        var input =
"""
a.b.items[2]{id,name}:
  1,A
  2,B
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":{"items":[{"id":1,"name":"A"},{"id":2,"name":"B"}]}}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "preserves literal dotted keys when expansion is off")]
    public void PreservesLiteralDottedKeysWhenExpansionIsOff()
    {
        // Arrange
        var input =
"""
user.name: Ada
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Off
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"user.name":"Ada"}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "expands and deep-merges preserving document-order insertion")]
    public void ExpandsAndDeepMergesPreservingDocumentOrderInsertion()
    {
        // Arrange
        var input =
"""
a.b.c: 1
a.b.d: 2
a.e: 3
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":{"c":1,"d":2},"e":3}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "throws on expansion conflict (object vs primitive) when strict=true")]
    public void ThrowsOnExpansionConflictObjectVsPrimitiveWhenStrictTrue()
    {
        // Arrange
        var input =
"""
a.b: 1
a: 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        Assert.Throws<ToonPathExpansionException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "throws on expansion conflict (object vs array) when strict=true")]
    public void ThrowsOnExpansionConflictObjectVsArrayWhenStrictTrue()
    {
        // Arrange
        var input =
"""
a.b: 1
a[2]: 2,3
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        Assert.Throws<ToonPathExpansionException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "applies LWW when strict=false (primitive overwrites expanded object)")]
    public void AppliesLwwWhenStrictFalsePrimitiveOverwritesExpandedObject()
    {
        // Arrange
        var input =
"""
a.b: 1
a: 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = false,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":2}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "applies LWW when strict=false (expanded object overwrites primitive)")]
    public void AppliesLwwWhenStrictFalseExpandedObjectOverwritesPrimitive()
    {
        // Arrange
        var input =
"""
a: 1
a.b: 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = false,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":2}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "preserves quoted dotted key as literal when expandPaths=safe")]
    public void PreservesQuotedDottedKeyAsLiteralWhenExpandpathsSafe()
    {
        // Arrange
        var input =
"""
a.b: 1
"c.d": 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":1},"c.d":2}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "preserves non-IdentifierSegment keys as literals")]
    public void PreservesNonIdentifiersegmentKeysAsLiterals()
    {
        // Arrange
        var input =
"""
full-name.x: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"full-name.x":1}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "expands keys creating empty nested objects")]
    public void ExpandsKeysCreatingEmptyNestedObjects()
    {
        // Arrange
        var input =
"""
a.b.c:
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
            ExpandPaths = ToonPathExpansion.Safe
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":{"c":{}}}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

}
