// <auto-generated>
//     This code was generated by ToonFormat.SpecGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>


using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Nodes;
using Toon.Format;
using Xunit;


namespace ToonFormat.Tests.Decode;


[Trait("Category", "decode")]
public class IndentationErrors
{
    [Fact]
    [Trait("Description", "throws when object field has non-multiple indentation (3 spaces with indent=2)")]
    public void ThrowsWhenObjectFieldHasNonMultipleIndentation3SpacesWithIndent2()
    {
        // Arrange
        var input =
"""
a:
   b: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        Assert.Throws<ToonFormatException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "throws when list item has non-multiple indentation (3 spaces with indent=2)")]
    public void ThrowsWhenListItemHasNonMultipleIndentation3SpacesWithIndent2()
    {
        // Arrange
        var input =
"""
items[2]:
   - id: 1
   - id: 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        Assert.Throws<ToonFormatException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "throws with custom indent size when non-multiple (3 spaces with indent=4)")]
    public void ThrowsWithCustomIndentSizeWhenNonMultiple3SpacesWithIndent4()
    {
        // Arrange
        var input =
"""
a:
   b: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 4,
            Strict = true,
        };

        Assert.Throws<ToonFormatException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "accepts correct indentation with custom indent size (4 spaces with indent=4)")]
    public void AcceptsCorrectIndentationWithCustomIndentSize4SpacesWithIndent4()
    {
        // Arrange
        var input =
"""
a:
    b: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 4,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":1}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "throws when tab character used in indentation")]
    public void ThrowsWhenTabCharacterUsedInIndentation()
    {
        // Arrange
        var input =
"""
a:
	b: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        Assert.Throws<ToonFormatException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "throws when mixed tabs and spaces in indentation")]
    public void ThrowsWhenMixedTabsAndSpacesInIndentation()
    {
        // Arrange
        var input =
"""
a:
 	b: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        Assert.Throws<ToonFormatException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "throws when tab at start of line")]
    public void ThrowsWhenTabAtStartOfLine()
    {
        // Arrange
        var input =
"""
	a: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        Assert.Throws<ToonFormatException>(() => ToonDecoder.Decode(input, options));
    }

    [Fact]
    [Trait("Description", "accepts tabs in quoted string values")]
    public void AcceptsTabsInQuotedStringValues()
    {
        // Arrange
        var input =
"""
text: "hello	world"
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"text":"hello\tworld"}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "accepts tabs in quoted keys")]
    public void AcceptsTabsInQuotedKeys()
    {
        // Arrange
        var input =
"""
"key	tab": value
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"key\ttab":"value"}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "accepts tabs in quoted array elements")]
    public void AcceptsTabsInQuotedArrayElements()
    {
        // Arrange
        var input =
"""
items[2]: "a	b","c	d"
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"items":["a\tb","c\td"]}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "accepts non-multiple indentation when strict=false")]
    public void AcceptsNonMultipleIndentationWhenStrictFalse()
    {
        // Arrange
        var input =
"""
a:
   b: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = false,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":1}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "accepts deeply nested non-multiples when strict=false")]
    public void AcceptsDeeplyNestedNonMultiplesWhenStrictFalse()
    {
        // Arrange
        var input =
"""
a:
   b:
     c: 1
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = false,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":{"b":{"c":1}}}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "empty lines do not trigger validation errors")]
    public void EmptyLinesDoNotTriggerValidationErrors()
    {
        // Arrange
        var input =
"""
a: 1

b: 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":1,"b":2}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "root-level content (0 indentation) is always valid")]
    public void RootLevelContent0IndentationIsAlwaysValid()
    {
        // Arrange
        var input =
"""
a: 1
b: 2
c: 3
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":1,"b":2,"c":3}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

    [Fact]
    [Trait("Description", "lines with only spaces are not validated if empty")]
    public void LinesWithOnlySpacesAreNotValidatedIfEmpty()
    {
        // Arrange
        var input =
"""
a: 1
   
b: 2
""";

        // Act & Assert
        var options = new ToonDecodeOptions
        {
            Indent = 2,
            Strict = true,
        };

        var result = ToonDecoder.Decode(input, options);

        var expected = JsonNode.Parse("""
{"a":1,"b":2}
""");

        Assert.True(JsonNode.DeepEquals(result, expected));
    }

}
